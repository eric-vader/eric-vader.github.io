<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Exam Clock</title>
<style>
    :root{
        --bg:#fff;
        --fg:#000;
        --muted:#444;
        --accent:#000;
    }
    html,body{
        height:100%;
        margin:0;
        background:var(--bg);
        color:var(--fg);
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Segoe UI Mono", "Courier New", monospace;
    }
    .wrap{
        box-sizing:border-box;
        height:100%;
        padding:24px;
        display:flex;
        flex-direction:column;
        justify-content:space-between;
        align-items:stretch;
    }
    header{
        display:flex;
        justify-content:space-between;
        align-items:center;
        gap:12px;
    }
    .info{
        display:flex;
        flex-direction:column;
        gap:4px;
    }
    .course{
        font-weight:600;
        font-size:20px;
        letter-spacing:0.02em;
    }
    .meta{
        color:var(--muted);
        font-size:13px;
    }
    .controls{
        display:flex;
        gap:8px;
        align-items:center;
    }
    button{
        background:transparent;
        border:1px solid var(--muted);
        color:var(--fg);
        padding:8px 12px;
        font-size:13px;
        border-radius:6px;
        cursor:pointer;
    }
    main{
        display:flex;
        flex-direction:column;
        align-items:center;
        justify-content:center;
        gap:18px;
        text-align:center;
        flex:1 1 auto;
    }
    .time{
        font-size:10em;
        font-weight:700;
        letter-spacing:0.02em;
    }
    .status{
        color:var(--muted);
        font-size:18px;
    }
    .secondary{
        display:flex;
        gap:24px;
        color:var(--muted);
        font-size:16px;
        flex-wrap:wrap;
        justify-content:center;
    }
    .bar{
        height:8px;
        background:#eee;
        border-radius:6px;
        overflow:hidden;
        width:100%;
        max-width:900px;
    }
    .bar > i{
        display:block;
        height:100%;
        background:var(--accent);
        width:0%;
    }
    footer{
        color:var(--muted);
        font-size:13px;
        text-align:center;
    }
    input{
        height:36px;padding:6px 12px;border-radius:6px;border:1px solid var(--muted);font-size:13px;box-sizing:border-box;background:transparent;color:inherit;
    }
    @media (max-width:600px){
        .time{ font-size:56px; }
        .course{font-size:16px;}
    }
</style>
</head>
<body>
<div class="wrap">
    <header>
        <div class="info">
            <div class="course" id="course">Course</div>
        </div>
        <div class="controls">
            <button id="pauseBtn">Pause</button>
            <button id="fsBtn">Enter Fullscreen</button>
        </div>
    </header>

    <main>
        <div class="time" id="mainTime">00:00:00</div>
        <div class="status" id="status">Status</div>
        <div class="secondary" id="secondary">
            <div id="started">Start: —</div>
            <div id="ends">End: —</div>
            <div id="elapsed">Elapsed: —</div>
            <div id="remaining">Remaining: —</div>
        </div>
        <div class="bar" aria-hidden="true"><i id="progress"></i></div>
    </main>

    <footer id="queryBuilder" >
        <form id="qbForm" style="display:flex;flex-wrap:wrap;gap:8px;justify-content:center;align-items:center;" method="GET">
            <input name="course" id="qbCourse" placeholder="Course (e.g. CS101)" />
            <input name="start" id="qbStart" type="datetime-local" required />
            <!-- <input name="end" id="qbEnd" type="time" required /> -->
            <input name="duration" id="qbDuration" placeholder="Duration (minutes)" type="number" min="1" required />
            <button type="submit">Apply</button>
            <button type="reset" id="qbClear">Clear</button>
        </form>
        <script>
            (function(){
                const params = Object.fromEntries(new URLSearchParams(location.search));
                const form = document.getElementById('qbForm');
                Array.from(form.elements).forEach(el => {
                    if (!(el instanceof HTMLInputElement)) {
                        return;
                    }
                    el.value = params[el.name] || '';
                });

                const builder = document.getElementById('queryBuilder');
                // hide builder if any relevant param is already present
                if(params.course && params.start && params.duration){
                    builder.style.display = 'none';
                    return;
                }

            })();
        </script>
    </footer>
</div>

<script>
/*
    Exam clock
    URL params:
        course - string
        start  - ISO datetime, or "HH:MM" (assumed today), or "YYYY-MM-DD HH:MM"
        end    - ISO datetime, or "HH:MM"
        duration - integer minutes (if start provided, end = start + duration; if only duration, start = now)
*/
(function(){
    const $ = id => document.getElementById(id);
    const params = Object.fromEntries(new URLSearchParams(location.search));
    const course = params.course || '';
    const durationParam = params.duration ? parseInt(params.duration,10) : null;
    const pauseBtn = $('pauseBtn');
    const fsBtn = $('fsBtn');

    function parseFlexibleDate(s, refDate){
        if(!s) return null;
        s = s.trim();
        // ISO
        if(/^\d{4}-\d{2}-\d{2}T/.test(s) || /\d{4}-\d{2}-\d{2} \d{2}:\d{2}/.test(s)){
            // accept space between date and time
            const normalized = s.replace(' ', 'T');
            const d = new Date(normalized);
            if(!isNaN(d)) return d;
        }
        // HH:MM or H:MM
        const tMatch = /^(\d{1,2}):(\d{2})(?::(\d{2}))?$/.exec(s);
        if(tMatch){
            const hh = parseInt(tMatch[1],10);
            const mm = parseInt(tMatch[2],10);
            const ss = tMatch[3] ? parseInt(tMatch[3],10) : 0;
            const d = refDate ? new Date(refDate) : new Date();
            d.setHours(hh, mm, ss, 0);
            return d;
        }
        // Try Date constructor fallback
        const d = new Date(s);
        return isNaN(d) ? null : d;
    }

    function formatTimeHMS(seconds){
        const s = Math.max(0, Math.floor(seconds));
        const hh = Math.floor(s/3600);
        const mm = Math.floor((s%3600)/60);
        const ss = s%60;
        if(hh>0) return `${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
        return `${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
    }
    function formatClock(date){
        if(!date) return '—';
        const hh = String(date.getHours()).padStart(2,'0');
        const mm = String(date.getMinutes()).padStart(2,'0');
        const ss = String(date.getSeconds()).padStart(2,'0');
        return `${hh}:${mm}:${ss}`;
    }
    function formatShort(date){
        if(!date) return '—';
        const hh = String(date.getHours()).padStart(2,'0');
        const mm = String(date.getMinutes()).padStart(2,'0');
        return `${hh}:${mm}`;
    }

    // Determine start and end
    const now = new Date();
    let start = parseFlexibleDate(params.start, now);
    let end   = parseFlexibleDate(params.end, now);

    if(durationParam && Number.isFinite(durationParam)){
        if(start){
            end = new Date(start.getTime() + durationParam*60000);
        } else {
            // start now
            start = new Date();
            end = new Date(start.getTime() + durationParam*60000);
        }
    }

    // If only end provided and it's earlier than now and looks like time-of-day, assume next day.
    if(!start && end){
        // set start as now
        start = null; // unknown
    }

    // If start and end both provided and end <= start assume end is next day
    if(start && end && end <= start){
        end = new Date(end.getTime() + 24*3600*1000);
    }

    // If only end provided and it's before now, try add 24h (user likely meant next day)
    if(!start && end && end <= new Date()){
        // if end parsed from HH:MM assume next day
        if(/^\d{1,2}:\d{2}/.test(params.end || '')){
            end = new Date(end.getTime() + 24*3600*1000);
        }
    }

    $('course').textContent = course || 'Exam';

    let paused = false;
    pauseBtn.addEventListener('click', ()=>{
        paused = !paused;
        pauseBtn.textContent = paused ? 'Resume' : 'Pause';
        const builder = document.getElementById('queryBuilder');
        if (builder.style.display === 'none') {
            builder.style.display = 'block';
        } else {
            builder.style.display = 'none';
        }
    });

    fsBtn.addEventListener('click', async ()=>{
        try{
            if(!document.fullscreenElement){
                await document.documentElement.requestFullscreen();
                fsBtn.textContent = 'Exit Fullscreen';
            } else {
                await document.exitFullscreen();
                fsBtn.textContent = 'Enter Fullscreen';
            }
        }catch(e){
            // ignore
        }
    });

    // Allow Space to toggle pause
    window.addEventListener('keydown', e=>{
        if(e.code === 'Space'){ e.preventDefault(); pauseBtn.click(); }
        if(e.code === 'KeyF'){ e.preventDefault(); fsBtn.click(); }
    });

    function update(){
        const now = new Date();
        const mainTime = $('mainTime');
        const status = $('status');
        const started = $('started');
        const ends = $('ends');
        const elapsed = $('elapsed');
        const remaining = $('remaining');
        const prog = $('progress');

        mainTime.textContent = formatClock(now);

        started.textContent = 'Start: ' + (start ? formatClock(start) : '—');
        ends.textContent = 'End: '   + (end ? formatClock(end) : '—');

        if(start && now < start){
            const toStart = (start.getTime() - now.getTime())/1000;
            status.textContent = 'Not started';
            elapsed.textContent = 'Until start: ' + formatTimeHMS(toStart);
            remaining.textContent = 'Remaining: —';
            prog.style.width = '0%';
        } else if(end){
            const totalSpan = start ? (end.getTime() - start.getTime())/1000 : null;
            const elapsedSec = start ? (now.getTime() - start.getTime())/1000 : null;
            const remainingSec = (end.getTime() - now.getTime())/1000;
            if(remainingSec <= 0){
                status.textContent = 'Finished';
                elapsed.textContent = start ? ('Elapsed: ' + formatTimeHMS(totalSpan)) : 'Elapsed: —';
                remaining.textContent = 'Remaining: 00:00';
                prog.style.width = '100%';
            } else {
                status.textContent = 'In progress';
                elapsed.textContent = start ? ('Elapsed: ' + formatTimeHMS(elapsedSec)) : 'Elapsed: —';
                remaining.textContent = 'Remaining: ' + formatTimeHMS(remainingSec);
                if(totalSpan && start){
                    const pct = Math.min(100, Math.max(0, (elapsedSec/totalSpan)*100));
                    prog.style.width = pct + '%';
                } else {
                    // if no start, show indeterminate-ish progress
                    prog.style.width = '0%';
                }
            }
        } else {
            // no end provided
            status.textContent = start ? 'Started' : 'No end time';
            elapsed.textContent = start ? ('Elapsed: ' + formatTimeHMS((now.getTime() - start.getTime())/1000)) : 'Elapsed: —';
            remaining.textContent = 'Remaining: —';
            prog.style.width = '0%';
        }
    }

    // initial focus: allow immediate FS with key
    window.addEventListener('load', ()=>{ document.body.focus(); });

    // Make sure clocks update every second even when paused (so UI stays current)
    setInterval(()=> {
        update();
    }, 1000);
    update();

})();
</script>
</body>
</html>